#### 선형대수학은 2차원과 3차원 기하학에 대한 모든것을 일반화해 임의의 차원인 데이터에 대한 연구를 한다.
#### 벡터공간은 벡터처럼 다룰 수 있는 객체의 집합이다.
#### 벡터공간의 주요 연산은 벡터합과 스칼라 곱이다. 이것을 통해 산술 부정, 뺼셈, 가중평균 등을 포함한 일차결합을 할 수 있다.


--------------------------------------------

## 6.1 우리가 만든 벡터의 정의 확장하기
#### 파이썬 클래스는 상속을 지원한다.
#### 기존 부모 클래스의 속성과 동작을 이어받는 새로운 클래스의 객체를 만들 수 있다.
#### 이 장에서는 2차원 벡터와 3차원 벡터를 일반적인 클래스 객체들의 특수한 사례로 두고 이 클래스의 객체들을 벡터라고 부른다.
#### 부록 [B]에 있는 내용을 먼저 보고 이어서 6장을 보도록 하겠다.

----------------------------------------------------

## 부록 B
### B.2.3. 제너레이터
####  
#### 제너레이터는 값을 메모리에 모두 저장하는 방식이 아니라 값을 생성하는 절차를 메모리에 저장하는 방식으로 이터러블을 만드는 방법을 제공한다.
#### 이런 제너레이터의 특성은 메모리에 양이 많은 유한수열이나 무한수열의 모든 값을 저장하지 않고도 정의할 수 있게 한다.
#### 제너레이터를 만드는 가장 기본적인 방법은 생성 절차를 함수처럼 만들되 return을 사용하지 않고 yield를 사용하면 된다.
#### 함수는 최대 한번만 return할 수 있고, return을 하면 함수가 종료되지만 제너레이터는 값을 여러번 걸쳐 yield할 수 있는 점에서 차이가 있다.


```python
def count():
    x = 0
    while True:
        yield x
        x += 1
        
# x가 1씩 증가하는 무한 수열
```


```python
count()
# 카운트를 하면 무한 수열이지만 무한루프에 빠지지 않고 수열 값의 리스트가 아닌 generator 객체를 리턴한다.
```




    <generator object count at 0x0000025EAE1B5C80>




```python
for x in count():
    if x > 1000:
        break
    else:
        print(x)
```

#### 위 코드 실행하면 0부터 999까지 프린트 된 후에 멈춘다.


```python
def count(a,b):
    x = a
    while x<b:
        yield x
        x += 1
```


```python
count(10,20)
# range(10,20)과 유사한 제너레이터
# 이 제너레이터가 산출하는 값을 바로 볼 수는 없지만 리스트 컴프리헨션을 이용하면 제너레이터에 대해 간접적으로 볼 수 있음
```




    <generator object count at 0x0000025EAE23F3C0>




```python
count(10,20)
[x for x in count(10,20)]
```




    [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]




```python
#### 리스트 컴프리헨션을 제너레이터 컴프리헨션을 바꾸면
(x*x for x in range(0,10))
```




    <generator object <genexpr> at 0x0000025EAE23F5F0>




```python
def squares():
    for x in range(0,10):
        yield x*x
# 제너레이터 만들기
```


```python
list(squares()) # 제너레이터가 유한개 값을 산출할 때 list 함수 사용
```




    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]



----------------------

### B.2.4. 튜플
#### 튜플은 불변이라는 점만 제외하면 리스트와 유사한 이터러블이다.
#### 튜플과 같은 불변 객체는 한번 만들어지면 변경이 불가하다. append와 같은 성분 추가 메서드도 존재하지 않는다.
#### 이런 특성으로 튜플은 2개 또는 3개씩 짝을 이루어 들어오는 데이터를 저장하는데 유리하다.
#### 튜플은 짧은 경우가 생각보다 많아 튜플을 반복하는 일은 드물다.
#### 이런 이유로 튜플 컴프리헨션은 존재하지 않는다.
#### 하지만 내장함수인 tuple로 컴프리헨션 결과를 받아 튜플로 변환할 수는 있다.



```python
a = 1,2,3,4,5
tuple(x+10 for x in a)
# 제너레이터 컴프리헨션의 결과가 tuple함수에 전달되는 것이다.
```




    (11, 12, 13, 14, 15)



------------------------

### B.2.5 셋
####   
#### 셋은 모든 성분이 서로 다른 컬렉션으로 셋의 성분 간에는 순서가 없다.
#### 중복된 값이 없음을 보장하기 위해 리스트를 셋으로 변환한 경우가 종종 있다.
#### 셋은 성분의 순서를 존중하지 않기 때문에 두 집합이 완전히 동일한 성분을 가지고 있으면 서로 같다고 간주한다.


```python
dups = [1,2,3,3,3,3,4,5,6,6,6,6,7,8,9,9,9,9]
print(set(dups))
print(list(set(dups)))
```

    {1, 2, 3, 4, 5, 6, 7, 8, 9}
    [1, 2, 3, 4, 5, 6, 7, 8, 9]
    


```python
set([1,1,2,2,3]) == {3,2,1}
```




    True



--------------------------------

### B.2.6 Numpy 배열
####   
#### Numpy는 수를 효율적으로 처리하는 수치 라이브러리이다.


```python
import numpy as np
```


```python
np.array([1,2,3,4,5,6])
# 파이썬 내장된 range 함수의 부동소수점 형태라고 보면 된다.
```




    array([1, 2, 3, 4, 5, 6])




```python
np.arange(0,10)
# 두개의 인자를 주면 np.arange는 range와 같은 방식으로 동작하지만 range 객체가 아니라 Numpy배열을 생성한다.
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
np.arange(0,5,0.1)
```




    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. , 1.1, 1.2,
           1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2. , 2.1, 2.2, 2.3, 2.4, 2.5,
           2.6, 2.7, 2.8, 2.9, 3. , 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8,
           3.9, 4. , 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9])




```python
len(np.arange(0,5,0.1))
# 세번째 인수로 수의 증분을 설정 할 수 있다.
# range 함수와는 달리 float가 될 수 있다.
```




    50



-------------------------

### B.2.7 딕셔너리
####   
#### 딕셔너리는 리스트, 튜플, 제너레이터와는 많이 다른 방식으로 동작한다.
#### 딕셔너리의 성분에 접근하려면 수로 된 인덱스를 사용하지 않고 key라고 하는 다른 데이터 조각으로 성분에 레이블을 붙인다.


```python
dog = {"name" : "Melba", "age": 2}
```


```python
dog = {
    "name" : "Melba",
    "age" : 2
}
# 같은 코드인데 가독성 향상을 위해 아래처럼 사용하는것이 좋음
```


```python
print(dog["name"])
print(dog["age"])
```

    Melba
    2
    


```python
list(dog.items())
# 딕셔너리의 모든 값을 가져오려면 딕셔너리의 items 메서드를 사용해 키-값 쌍에 해당하는 튜플로 이루어진 이터러블을 얻으면 된다.
# 딕셔너리는 값을 정렬하지 않고 저장하므로 items 메서드의 결과도 특정 순서를 따른다고 예상하면 안된다.
```




    [('name', 'Melba'), ('age', 2)]



-------------------

### B.2.8 컬렉션과 관련된 유용한 함수
####   
#### 책에서는 sum, max, min, reversed 등 다양한 것을 소개했는데 간단하게 sorted만 보고 가겠다.
#### sorted 함수는 이터러블을 정렬한 복사본에 해당하는 리스트를 리턴한다.
#### sorted가 새로운 이터러블이 아니라 새로운 리스트를 리턴한다는 점에 유의해야 한다.


```python
q = [3,4,1,2,5]
print(sorted(q))
print(q)
```

    [1, 2, 3, 4, 5]
    [3, 4, 1, 2, 5]
    

-----------------------------------

## B.3 함수 활용하기
###   
### B.3.1 함수에 여러 입력 주기
#### 함수에는 필요한 만큼의 입력, 즉 인자를 주어 정의할 수 있다.
#### 때로는 단일 함수가 인자 개수를 제약 없이 받아들일 수 있으면 좋다.
#### add 함수를 만들어 예시를 들어보겠다.


```python
def add(*args):
    total = 0
    for x in args :
        total += x
    return total
# args에 *을 붙여 인자에 대해 반복하는 함수 로직을 자유롭게 작성 할 수 있다.
# add 함수는 전달된 모든 인자에 대해 반복하며 더한 합계를 리턴한다.
```


```python
print(sum([1,2,3,4,5]))
print(add(1,2,3,4,5))
```

    15
    15
    


```python
p = [1,2,3,4,5]
add(*p)
# 리스트를 별표 연산자의 입력으로 주어 리스트의 성분을 함수의 인자로 변환할 수 있다.
```




    15



-------------------------

### B.3.2 키워드 인자
####   
#### 별표를 붙인 인자를 함수에 사용하면 매개변수의 사용 여부를 선택할 수 있다.
#### 이런 매개변수를 선택적으로 사용하는 또 하나의 방법은 키워드인자라고 한다.
#### 인자에 이름을 붙여 전달하는 방법이다.


```python
def birthday(name="friend", age = None):
    s = "Happy birthday, %s" % name
    if age:
        s += ", you're %d years old" % age
    return s + "!"
# %s가 등장하면 그에 대응하는 주어진 문자열로 대체, %d가 등장하면 그에 대응하는 주어진 수로 대체한다.

```


```python
birthday()
```




    'Happy birthday, friend!'




```python
print(birthday('Melba'))
print(birthday(name = 'Melba'))
# 첫번째 인자는 name 이라는 매개변수의 인자로 간주되지만 아래와 같이 직접 명시할 수도 있다.
```

    Happy birthday, Melba!
    Happy birthday, Melba!
    


```python
print(birthday('Melba',2))
print(birthday(age = 2))
print(birthday('Melba',age = 2))
print(birthday(age = 2, name = 'Melba'))
```

    Happy birthday, Melba, you're 2 years old!
    Happy birthday, friend, you're 2 years old!
    Happy birthday, Melba, you're 2 years old!
    Happy birthday, Melba, you're 2 years old!
    


```python
# 인수가 많으면 딕셔너리로 묶은 뒤 딕셔너리에 **연산자를 붙여 함수에 전달할 수도 있다
dog = {"name" : "Melba", "age" : 2 }
print(dog)
print(birthday(**dog))

```

    {'name': 'Melba', 'age': 2}
    Happy birthday, Melba, you're 2 years old!
    


```python
# ** 연산자를 사용하면 함수에 주어진 모든 키워드 인자를 하나의 딕셔너리로 모아준다.
def birthday(**kwargs):
    s = "Happy birthday, %s" % kwargs['name']
    if kwargs['age']:
        s +=", you're %d years old" % kwargs['age']
    return s + "!"
```


```python
print(birthday(**dog))
print(birthday(age=2, name ='Melba'))
```

    Happy birthday, Melba, you're 2 years old!
    Happy birthday, Melba, you're 2 years old!
    

----------------------------

### B.3.3. 데이터로서의 함수
####    
#### 파이썬에서 함수는 일류 객체라고들 한다.
#### 함수에 변수를 할당할 수 있으며, 함수를 다른 함수에 전달할 수도 있는데다 다른 함수의 출력값으로 리턴할 수 있다.


```python
def evaluate(f,x):
    return f(x)
# 함수 f와 값 x라는 두 개의 입력을 받아서 f(x)라는 값을 리턴한다.
```


```python
def square(x):
    y = x*x
    return y

evaluate(square,10)
```




    100



#### map 함수는 함수와 이터러블을 입력으로 받아서 이터러블의 각 성분에 함수를 적용해 얻은 새 이터러블을 리턴한다.


```python
print(map(square,range(10)))
print(list(map(square,range(10))))
```

    <map object at 0x0000025EAE675F70>
    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    


```python
# evaluate 함수와 map함수는 다른 함수를 입력으로 받은 함수들의 예시이다.
# 아래의 함수는 수를 특정 횟수만큼 거듭제곱하는 함수를 리턴한다.
def make_power_function(power):
    def power_function(x):
        return x ** power
    return power_function
```


```python
square = make_power_function(2) # 입력값의 제곱
print(square(2))
cube = make_power_function(3) # 입력값의 세제곱
print(cube(2))
```

    4
    8
    

#### make_power_function이 실행을 완료한 이후에도 리턴된 power_function은 make_power_function에 전달된 power변수를 계속 기억한다.
#### 이는 일반 함수의 변수가 함수의 실행 종료와 함께 사라지는 것과 다르다. 이렇게 함수의 정의 내부에서 사용된 외부 변수를 계속 기억하는 함수를 클로저라고 한다.

---------------------------

### B.3.4 lambda : 익명함수
####   
#### lambda라는 키워드는 이름 없이 함수를 만들 수 있게 한다. 
#### 람다에 단일 입력 x를 받아 2를 더해 리턴하는 함수를 정의해보겠다.


```python
lambda x: x+2
```




    <function __main__.<lambda>(x)>




```python
(lambda x:x+2)(7)
```




    9




```python
(lambda x,y: x+ 2 *y)(2,3)
```




    8




```python
# 보통 람다를 쓸만한 상황은 다른 함수를 리턴하는 함수를 작성할 때이다.
def make_power_function(p):
    return lambda x : x**p
make_power_function(2)(3)
```




    9




```python
map(lambda x : x+2, range(0,9)) # 람다를 함수의 입력으로 사용할 수도 있다.
```




    <map at 0x25eae77a550>




```python
[x+2 for x in range(0,9)] # 데이터를 보기 위해 결과를 리스트로 변환 
```




    [2, 3, 4, 5, 6, 7, 8, 9, 10]




```python

```
